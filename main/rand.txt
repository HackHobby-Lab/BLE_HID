/*  Minimal BLE HID Consumer-Control demo for ESP32-S3 (NimBLE)
 *  Sends VOL-UP / VOL-DOWN alternately every 2 s.
 *  Build: idf.py menuconfig → Component-config → Bluetooth → NimBLE
 *  © 2025  You may use under CC0 / Unlicense
 */
#include "esp_log.h"
#include "nvs_flash.h"
#include "esp_hidd.h"
#include "esp_hid_gap.h"

#include "nimble/nimble_port.h"
#include "nimble/nimble_port_freertos.h"
#include "host/ble_hs.h"

static const char *TAG = "HID_MIN";

/* ───────────────────────── Report Map (Consumer-Control) ──────────────────── */
static const uint8_t consumer_map[] = {
    0x05,0x0C,                /* Usage Page (Consumer)          */
    0x09,0x01,                /* Usage (Consumer Control)       */
    0xA1,0x01,                /* Collection (Application)       */
    0x85,0x01,                /*  Report ID 1                   */
    0x15,0x00,0x25,0x01,      /*  LOG_MIN 0, LOG_MAX 1          */
    0x09,0xE9,                /*  Usage (Volume Up)             */
    0x09,0xEA,                /*  Usage (Volume Down)           */
    0x75,0x01,0x95,0x02,0x81,0x06, /* 2 bits Rel Input          */
    0x09,0xE2,                /*  Usage (Mute)                  */
    0x75,0x01,0x95,0x01,0x81,0x06, /* 1 bit Rel Input            */
    0x95,0x05,0x81,0x03,      /*  5 bits padding (Const)        */
    0xC0                       /* End Collection                 */
};

/* ───────────────────────── Globals ─────────────────────────────── */
static esp_hidd_dev_t *hid_dev;

/* ───────────────────────── Helpers ─────────────────────────────── */
static void send_consumer(uint16_t usage)
{
    uint8_t rpt[2] = {usage & 0xFF, usage >> 8};      /* press */
    esp_hidd_dev_input_set(hid_dev, 0, 1, rpt, sizeof(rpt));
    vTaskDelay(pdMS_TO_TICKS(30));                    /* release */
    rpt[0] = rpt[1] = 0;
    esp_hidd_dev_input_set(hid_dev, 0, 1, rpt, sizeof(rpt));
}

static void volume_task(void *arg)
{   
            // vTaskDelay(pdMS_TO_TICKS(20000));
    bool up = true;
    while (1) {
        send_consumer(up ? 0xE9 /*VOL+*/ : 0xEA /*VOL-*/);
        up = !up;
        vTaskDelay(pdMS_TO_TICKS(2000));
    }
}

/* HID / GAP events: start advertising, spawn task on connect */
static void hid_cb(void *arg, esp_event_base_t base, int32_t id, void *data)
{
    switch (id) {
    case ESP_HIDD_START_EVENT:
        esp_hid_ble_gap_adv_start();                          break;
    case ESP_HIDD_CONNECT_EVENT:
        xTaskCreate(volume_task, "vol", 4096, NULL, 5, NULL); break;
    case ESP_HIDD_DISCONNECT_EVENT:
        esp_hid_ble_gap_adv_start();                          break;
    default:                                                  break;
    }
}

/* NimBLE host task (required) */
static void ble_host_task(void *param)
{
    ESP_LOGI(TAG, "NimBLE host running");
    nimble_port_run();
    nimble_port_freertos_deinit();
}

/* ───────────────────────── app_main ────────────────────────────── */
void app_main(void)
{
    ESP_ERROR_CHECK(nvs_flash_init());
    ESP_ERROR_CHECK(esp_hid_gap_init(ESP_HID_TRANSPORT_BLE));

    /* Advertise as a generic HID */
    ESP_ERROR_CHECK(esp_hid_ble_gap_adv_init(ESP_HID_APPEARANCE_GENERIC,
                                             "Azmuth"));

    /* Device-level configuration */
    esp_hid_raw_report_map_t map = { .data = consumer_map,
                                     .len  = sizeof(consumer_map) };

    esp_hid_device_config_t cfg  = {
        .vendor_id         = 0x16C0,
        .product_id        = 0x05DF,
        .version           = 0x0100,
        .device_name       = "Azmuth",
        .manufacturer_name = "Espressif",
        .serial_number     = "123456",
        .report_maps       = &map,
        .report_maps_len   = 1
    };

    ESP_ERROR_CHECK(esp_hidd_dev_init(&cfg,
                                      ESP_HID_TRANSPORT_BLE,
                                      hid_cb, &hid_dev));

    /* Start the NimBLE stack */
    extern void ble_store_config_init(void);  /* IDF helper */
    ble_store_config_init();
    ESP_ERROR_CHECK(esp_nimble_enable(ble_host_task));
}
